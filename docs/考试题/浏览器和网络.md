### 说明下跨域问题

* 浏览器的同源策略

  为了防止从不同的`源`加载资源导致安全问题，浏览器限定只能访问同源的资源。

  解决跨域就是让浏览器发起资源请求时，不光能收到返回的数据，而且浏览器能解出返回的数据给前端用。

  跨域也是保护后台，别什么地方过来的请求，我都响应你。
  
  * 什么是同源
  
    简单说，就是协议+网址+端口 组合起来的url必须是相同的
    
    **protocol:** `http` `https`
    
    **domain:** `www.baidu.com`
    
    `example.com`和`sub.example.com`不是同一个域名
    
    **port:** `8080`
  
  * 解决方案
  
    `Access-Control-Allow-Origin`
  
    后台解决：服务器告诉浏览器，我这个数据返给你了，并且通过`CORS`的规则，你可以认为是合法资源，放心用吧
  
    `Access-Control-xxxxx` 相关的请求头是跟跨域设置有关的

* 简单请求 和 复杂请求

  简单请求，不需要直接发起预检请求，直接把请求发出去了，后台去判断，该响应响应，不响应拉到

  复杂请求，先发起预检请求`HTTP OPTIONS`，通过后，说明后台乐意搭理你，浏览器再自动发起真正的请求，后台去真实走逻辑

**扩展**

https://www.youtube.com/watch?v=dl-e69QnA08

### 事件机制

* 事件添加了，就一定要移除，否则内存溢出

### 浏览器解析

拿到`html`文档，也就是网络链接发回来那一大长串字符串，要解析成对象树才能供程序用：`dom`树和`cssom`树

总体的规则是遇到`js`处理`js`，遇到`css`处理`css`。这是总的规则，但处理起来情况有所不同：

* 遇到`css`文件，不会耽误主线程的后续解析，不会阻塞，会有一个预解析线程去处理。预解析线程遇到外部`css`文件，会启动网络线程加载。加载完后给预解析线程再次解析`css`文本到对象，再交给主线程用

* 遇到`script`写的代码，如果是可以执行的，比如立即执行函数，就会执行`js`代码。如果是不可执行的，比如定义一堆变量和方法，那就是挂载到作用域上。

* 如果是些外部链接的代码，那就暂停`html`解析，然后去下载对应的代码。下载完以后，可执行的就执行，可挂载的就挂载，然后继续`html`解析。

  > 对比`css` 和`js`，`css` 并不会阻断`html`解析，而`js`代码会阻断。而阻断了`html`解析，就意味着延迟了页面上看到元素的时机。这就是为啥有些地方说要把`js`在后面嵌入。
  >
  > `js`代码执行是会导致`dom`结构发生巨大差异的，所以到了`js`就会暂停此时主线程对于`dom`结构的解析

**项目里有很多第三方库是通过`index.html` 里的 `script` 标签引入的，而且放到前面去，这就会导致在加载时，要花费大量时间去加载这些`js`代码，然后执行它们，页面元素的显示就会延迟，屏幕就会在这段时间内白屏**



