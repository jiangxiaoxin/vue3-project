# pinia 状态管理

总的来说，pinia 很简单，api 也简单，就是提供初始化状态，这些小状态本身就已经是ref，reactive包装过的响应式数据，所以后面去修改和访问时当然就是响应式变化的。

这跟在react 里用 hook的方式去管理组件间数据是类似的。 vue 3 的 composition Api 使得响应式数据可以跳出具体的组件作用域，简单说就是可以不用在 .vue 文件的代码里去创建响应式数据，而是可以单独在一个 js 文件里创建这些响应式数据，通过导出 （export），这些数据在别的地方被引用时，也是保持响应式的。

状态管理最大的场景是统一维护复杂的状态树。

如果是父子组件，那标准做法是通过 `props + event` 方式来做。

如果是兄弟组件，标准做法是通过 `公共父组件 + props + event` 来做

小数据量，简单数据，对于无关组件之间，可以通过 `cookie` 和 `storage`来做

> 当然是有弊端的，比如 `cookie` 别全局禁用，传递信息的暴露,但这仍不失为一种简单有效直接的方式。

还可以通过 `event flow`来做。典型就是通过全局 `EventEmitter` 来自做事件监听和传递。

> `EventEmitter` 本身很简单，就是个`event type` 和`event handler`的映射记录。只是处理好事件执行时的作用域即可。

对于多处数据，多处使用，可以考虑 pinia

1. 最大的问题依然是刷新后数据就会清零，重新开始，前后数据不会保持。

    不过这也正常，对于前端，刷新就是一种重新开始，整个页面会从新解析创建，js代码也会重新走parser，方法就是会重新走，useXXXStore的方法重新走，那就注定会重新生产 store 对象.

    其他的几种方式同样不可能保持前后的数据。

    有一种扩展用法，也是之前 vuex 时的用法，会将 vuex 数据变化后沉淀到 storage 中，当刷新后，以本地 storage 中的数据来恢复。

    1.1 那什么时候需要用pinia？它的使用场景是什么？

    上面已经对比了不同场景下可选择的方案。选择pinia应该是最后的手段了

2. 调用useXXX方法以后，得到的store里的数据就可以响应式的使用了.但要注意：不能对store进行解构操作，否则就会丢失响应式。又想解构（这样用起来方便），又不想丢失响应式，需要对返回的store对象进行 `storeToRefs` 解构才可以

3. 第一行代码 effectScope 用来干嘛的。也就是 effectScope的作用。

    在 core 整个项目下已经做了解析了。就是搞了一个 effect 的执行作用域
