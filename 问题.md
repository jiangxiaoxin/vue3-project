## 库

### [x] axios

感觉axios也没啥要看的，只要注意怎么使用就行了。本质就是 XHR呀

1. axios的常见封装和使用
2. axios的源码分析。能学到啥。

### vue

1. ref 和 reactive 多场景测试
2. watch 和 watchEffect 的对比
3. provide 和 inject 有啥作用？使用场景？

在父级组件里通过provide方法声明一下，”我会提供数据给你们，你们用就行了“。在子级容器里，通过inject注入这份数据，在子组件里就可以使用了。

这份数据没什么特殊性，number，string，boolean，object，等普通数据都可以。还可以是ref，reavtive的响应式数据，并且父组件里数据变了，子组件里是变的

inject 第二个参数可以注入个默认值。

4. [x] teleport 能用来干什么

让组件的实际渲染位置跳出它所在的逻辑位置。最典型的使用场景就是modal，模态框

比如组件a下有个组件b，组件b会渲染在组件a内,a是b的父容器，b是a的子元素.但通过teleport就可以让组件b的实际渲染位置跳出a，而是渲染到指定的元素下，而同时保持组件a和组件b之间的逻辑上的父子组件关系。原来的父子间数据传递关系不变。

teleport 可以嵌套使用。

还可以多个不同的teleport共享同一个父容器。

5. slot 插槽的使用。

很常见的例子，就是那种带自定义显示的组件，到处都是。dialog，form，table

6. keeplive

7. computed

8. scoped 的样式

样式作用域，为了隔离样式而来。在 scoped 标记下的css样式，会在class添加特殊标记，而不在仅仅是个class了。

a. 父组件里有个普通的样式 classA，在子组件里是可以访问到的。并且子组件内可以写同名的样式，不管是写scoped class 还是普通 class, 这两个样式都能匹配到，所以会进行样式的合并.

> 但是父子同名的 classA，他们相同的属性到底谁最后有效呢？

b. 父组件里scoped 包围的样式 classB， 在子组件内无法访问到。子组件内可以写同名样式，对子组件也只应用自己写的样式.

c. 对于两个同级的兄弟组件，那各自有各自的范围，scoped的样式只应用自己

d. 兄弟组件，两个都写同名的普通 class，不用scoped 限定范围，那谁里面的有效呢？肯定不是都有效，但我也没总结出固定的逻辑。

9. 写组件的几种方式

   a. 最常见的 template script style那种方式,写 sfc vue文件

   b. 用tsx文件来写组件，defineComponent包装一下，里面写一个大的setup，最后返回一个render函数，就可以了

   这种tsx的方式，只是用tsx的语法来写vue的组件，用的还是vue的ref，watch这些api，不是用react。这不能搞混了。useState，useEffect 这些是没有的.

   > 有一点非常重要，在.vue文件里，template 里的`{{ count }} `是会自动解出它的value属性，但是在tsx中，人家就不知道了，`<span>{ count.value }</span>`这样才能显示count的值

   tsx 是纯ts代码，它不能写 css，要将css 单独写成文件，然后import进去，使用module css，可以将这些class 当成变量一样绑定

### vue router

### [x] pinia

总的来说，pinia 很简单，就是提供初始化状态，这些小状态本身就已经是ref，reactive包装过的响应式数据，所以后面去修改和访问时当然就是响应式变化的。没啥好考的，正常使用就行了。

1. 最大的问题依然是刷新后数据就会清零，重新开始。不过这也正常，对于前端，刷新就是一种重新开始，方法就是会重新走，useXXXStore的方法重新走，那就注定会重新生产 store 对象.

1.1 那第一个问题：什么时候需要用pinia？它的使用场景是什么？

2. 调用useXXX方法以后，得到的store里的数据就可以响应式的使用了.但要注意：不能对store进行解构操作，否则就会丢失响应式。又想解构（这样用起来方便），又不想丢失响应式，需要对返回的store对象进行 `storeToRefs` 解构才可以

3. 第一行代码 effectScope 用来干嘛的。也就是 effectScope的作用。

### element plus vue

1. config provider
2. [x] dialog

### vue query

### react

1. 常见的几个api，使用的场景和注意事项

2. 常见hook的使用。

3. 自定义hook

4. hook库

## web基础

1. 啥是跨域？怎么解决？
2. 缓存策略

   [强缓存和协商缓存](https://juejin.cn/post/6844903717574017031)

   两个都是用来判断浏览器是否可以使用本地已经有的资源，包括html ，css，js， img等。

   不同的是强制缓存不发起请求，浏览器直接就刹停了，服务器一点消息也没有。而协商缓存，是跟服务器协商下，看服务器觉得可不可以用缓存。如果不可以的话，就会发过来新的资源。

   强制缓存命中，code返回为200. 协商缓存命中，code返回是304

## css基础

1. 盒子模型
2. position
3. flex布局
4. grid布局
5. 居中
6. 块元素，行内元素
7. 常见的伪类和伪元素

## js基础

## 工具链

### vite

1. mock 的配置
2. dev server的配置
3. 常用的配置项

console.log 的隐藏

4. vite 插件。

打包时在html里写入一些打包信息
