1.手写冒泡排序
2.动态规划，上台阶，100级台阶，一次可以上1个或者2个，问总共有多少种方法。
3.遍历二叉树
4.深度/广度遍历，一颗树，按照输入，查找对应的节点。
5.websocket 重连和判活
6.大量数据发送和接受，发送和渲染队列

## 对按钮做信息收集

```
install 自定义指令，让指令对象对应的div监听 click 事件。
mounted 时监听，beforeUnmount 时再移除，不会泄露
```

### 多次点击同一个按钮，统计重复吗？

```
看情况，如果需求确实点击一次就统计一次，那是可以的
如果只认定一次，那可以使用 once的方式，mounted 后监听click。点击后就去发送，发送后就删除事件，不在监听click
如果可以重复点击，但是不要频繁，那就是监听的click回调加上debounce
```

### 怎么发的请求？

```
就是发起个ajax请求。
```

### 但 XMLHttpRequest 实例是不是太多了？

```
如果不是太频繁的统计，或者统计数据暂存本地发送列表，每隔2s发送一次，实例多也无所谓
每隔2s发送一次，并不只是发送一条数据，可以几条数据一起发送。这样快速发到服务器上保存数据，同时尽量大的利用一次请求机会。
```

### 同一个页面，假如多个可见后要统计，短时间多次请求，是不是跟别的请求竞争？怎么处理短时大量？

```
一定要做发送队列，不是点击立马就发送。可以点击立马记录响应的点击时间和数据到发送队列里
对同一个请求，做发送队列，每次只能传递一个请求，这样直到发送完。或者可以限制同时的请求次数，可以用promise+数组的形式
在many-request.js里有个限制同时请求的例子
```

### 既然是发送队列，那最后会不会有数据是放入队列，但没发送到服务器统计到呢？

```
肯定会有，但这种一般情况很少。还是考虑实际，除非是前面大量统计对象挤压，点击后几秒钟内就关掉页面，这种操作一般也不是目标操作和用户了，或者失去统计的价值。
可以 sendBecon 在关闭时异步一次性发送。但也不能发送太多数据量。
可以本地在做个localstorage缓存，发送过的就移除，没发送的就暂存。这样下次登录再从缓存里取出，直接放入队列。这样就不能sendBeacon，因为sendBecon 不确保是一定能发送成功的。清理缓存然后用sendBecon发送，并不能确保真的都发送了，也就没法确定清理是不是对的了。
每条一个id？重复的就抛弃？
没有完全准备的统计，只能是保证大部分场景下是完备的。
```

### 自定义指令，绑了自定义对象数据，并且会变的，那怎么获取呢？

```shell
参数中的binding 会有这些数据，可以直接访问到，且是响应式变化的
```
